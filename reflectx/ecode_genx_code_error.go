// Package reflectx GENERATED BY code_error DO NOT EDIT
package reflectx

import (
	"errors"
	"fmt"
)

func (e Ecode) Message() string {
	switch e {
	default:
		return fmt.Sprintf("[PARSING_TAG:%d] unknown", e)
	case ECODE_UNDEFINED:
		return "[PARSING_TAG:0] undefined"
	case ECODE__INVALID_FLAG_KEY:
		return "[PARSING_TAG:1] invalid flag key"
	case ECODE__INVALID_FLAG_VALUE:
		return "[PARSING_TAG:2] invalid flag value"
	case ECODE__INVALID_FLAG_NAME:
		return "[PARSING_TAG:3] invalid flag flag name"
	case ECODE__INVALID_OPTION_KEY:
		return "[PARSING_TAG:4] invalid option key"
	case ECODE__INVALID_OPTION_VALUE:
		return "[PARSING_TAG:5] invalid option value"
	case ECODE__INVALID_OPTION_UNQUOTED:
		return "[PARSING_TAG:6] invalid option unquoted"
	}
}

func NewEcodeError(code Ecode) error {
	return &EcodeError{
		code: code,
	}
}

func NewEcodeErrorf(code Ecode, msg string, args ...any) error {
	return &EcodeError{
		code: code,
		msg:  msg,
		args: args,
	}
}

func NewEcodeErrorWrap(code Ecode, cause error) error {
	if cause == nil {
		return nil
	}
	return &EcodeError{
		code:  code,
		args:  []any{cause},
		cause: cause,
	}
}

func NewEcodeErrorWrapf(code Ecode, cause error, msg string, args ...any) error {
	if cause == nil {
		return nil
	}
	return &EcodeError{
		code:  code,
		msg:   msg,
		args:  append(args, cause),
		cause: cause,
	}
}

type EcodeError struct {
	code  Ecode
	msg   string
	args  []any
	cause error
}

func (e *EcodeError) Error() string {
	msg := e.code.Message()
	if len(e.msg) > 0 {
		msg += ". " + e.msg
	}
	if e.cause != nil {
		msg += ". [cause: %+v]"
	}
	return fmt.Sprintf(msg, e.args...)
}

func (e *EcodeError) Code() Ecode {
	return e.code
}

func (e *EcodeError) Is(err error) bool {
	var target *EcodeError
	return errors.As(err, &target) && target.code == e.code
}

func (e *EcodeError) Unwrap() error {
	return e.cause
}
